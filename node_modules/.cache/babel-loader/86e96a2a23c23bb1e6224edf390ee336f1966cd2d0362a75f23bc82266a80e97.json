{"ast":null,"code":"import _classCallCheck from \"/Users/noamsebahoun/Documents/MMI/MMI_3/karl/three-reader-live/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/noamsebahoun/Documents/MMI/MMI_3/karl/three-reader-live/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/noamsebahoun/Documents/MMI/MMI_3/karl/three-reader-live/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/noamsebahoun/Documents/MMI/MMI_3/karl/three-reader-live/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { AdditiveBlending, Color, HalfFloatType, MeshBasicMaterial, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nvar UnrealBloomPass = /*#__PURE__*/function (_Pass) {\n  _inherits(UnrealBloomPass, _Pass);\n  var _super = _createSuper(UnrealBloomPass);\n  function UnrealBloomPass(resolution, strength, radius, threshold) {\n    var _this;\n    _classCallCheck(this, UnrealBloomPass);\n    _this = _super.call(this);\n    _this.strength = strength !== undefined ? strength : 1;\n    _this.radius = radius;\n    _this.threshold = threshold;\n    _this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n\n    // create color only once here, reuse it later inside the render function\n    _this.clearColor = new Color(0, 0, 0);\n\n    // render targets\n    _this.renderTargetsHorizontal = [];\n    _this.renderTargetsVertical = [];\n    _this.nMips = 5;\n    var resx = Math.round(_this.resolution.x / 2);\n    var resy = Math.round(_this.resolution.y / 2);\n    _this.renderTargetBright = new WebGLRenderTarget(resx, resy, {\n      type: HalfFloatType\n    });\n    _this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n    _this.renderTargetBright.texture.generateMipmaps = false;\n    for (var i = 0; i < _this.nMips; i++) {\n      var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n      renderTargetHorizonal.texture.generateMipmaps = false;\n      _this.renderTargetsHorizontal.push(renderTargetHorizonal);\n      var renderTargetVertical = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n      renderTargetVertical.texture.generateMipmaps = false;\n      _this.renderTargetsVertical.push(renderTargetVertical);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n\n    // luminosity high pass material\n\n    var highPassShader = LuminosityHighPassShader;\n    _this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n    _this.highPassUniforms['luminosityThreshold'].value = threshold;\n    _this.highPassUniforms['smoothWidth'].value = 0.01;\n    _this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: _this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader\n    });\n\n    // gaussian blur materials\n\n    _this.separableBlurMaterials = [];\n    var kernelSizeArray = [3, 5, 7, 9, 11];\n    resx = Math.round(_this.resolution.x / 2);\n    resy = Math.round(_this.resolution.y / 2);\n    for (var _i = 0; _i < _this.nMips; _i++) {\n      _this.separableBlurMaterials.push(_this.getSeperableBlurMaterial(kernelSizeArray[_i]));\n      _this.separableBlurMaterials[_i].uniforms['invSize'].value = new Vector2(1 / resx, 1 / resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n\n    // composite material\n\n    _this.compositeMaterial = _this.getCompositeMaterial(_this.nMips);\n    _this.compositeMaterial.uniforms['blurTexture1'].value = _this.renderTargetsVertical[0].texture;\n    _this.compositeMaterial.uniforms['blurTexture2'].value = _this.renderTargetsVertical[1].texture;\n    _this.compositeMaterial.uniforms['blurTexture3'].value = _this.renderTargetsVertical[2].texture;\n    _this.compositeMaterial.uniforms['blurTexture4'].value = _this.renderTargetsVertical[3].texture;\n    _this.compositeMaterial.uniforms['blurTexture5'].value = _this.renderTargetsVertical[4].texture;\n    _this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n    _this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n    var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n    _this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n    _this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n    _this.compositeMaterial.uniforms['bloomTintColors'].value = _this.bloomTintColors;\n\n    // blend material\n\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.blendMaterial = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.enabled = true;\n    _this.needsSwap = false;\n    _this._oldClearColor = new Color();\n    _this.oldClearAlpha = 1;\n    _this.basic = new MeshBasicMaterial();\n    _this.fsQuad = new FullScreenQuad(null);\n    return _this;\n  }\n  _createClass(UnrealBloomPass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n        this.renderTargetsHorizontal[i].dispose();\n      }\n      for (var _i2 = 0; _i2 < this.renderTargetsVertical.length; _i2++) {\n        this.renderTargetsVertical[_i2].dispose();\n      }\n      this.renderTargetBright.dispose();\n\n      //\n\n      for (var _i3 = 0; _i3 < this.separableBlurMaterials.length; _i3++) {\n        this.separableBlurMaterials[_i3].dispose();\n      }\n      this.compositeMaterial.dispose();\n      this.blendMaterial.dispose();\n      this.basic.dispose();\n\n      //\n\n      this.fsQuad.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resx = Math.round(width / 2);\n      var resy = Math.round(height / 2);\n      this.renderTargetBright.setSize(resx, resy);\n      for (var i = 0; i < this.nMips; i++) {\n        this.renderTargetsHorizontal[i].setSize(resx, resy);\n        this.renderTargetsVertical[i].setSize(resx, resy);\n        this.separableBlurMaterials[i].uniforms['invSize'].value = new Vector2(1 / resx, 1 / resy);\n        resx = Math.round(resx / 2);\n        resy = Math.round(resy / 2);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      var oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      renderer.setClearColor(this.clearColor, 0);\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n\n      // Render input to screen\n\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.basic;\n        this.basic.map = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n      }\n\n      // 1. Extract Bright Areas\n\n      this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n      this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n      this.fsQuad.material = this.materialHighPassFilter;\n      renderer.setRenderTarget(this.renderTargetBright);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n\n      // 2. Blur All the mips progressively\n\n      var inputRenderTarget = this.renderTargetBright;\n      for (var i = 0; i < this.nMips; i++) {\n        this.fsQuad.material = this.separableBlurMaterials[i];\n        this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n        this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n        this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetsVertical[i]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        inputRenderTarget = this.renderTargetsVertical[i];\n      }\n\n      // Composite All the mips\n\n      this.fsQuad.material = this.compositeMaterial;\n      this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n      this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n      this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n\n      // Blend it additively over the input texture\n\n      this.fsQuad.material = this.blendMaterial;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      } else {\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n      }\n\n      // Restore renderer settings\n\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n  }, {\n    key: \"getSeperableBlurMaterial\",\n    value: function getSeperableBlurMaterial(kernelRadius) {\n      var coefficients = [];\n      for (var i = 0; i < kernelRadius; i++) {\n        coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);\n      }\n      return new ShaderMaterial({\n        defines: {\n          'KERNEL_RADIUS': kernelRadius\n        },\n        uniforms: {\n          'colorTexture': {\n            value: null\n          },\n          'invSize': {\n            value: new Vector2(0.5, 0.5)\n          },\n          // inverse texture size\n          'direction': {\n            value: new Vector2(0.5, 0.5)\n          },\n          'gaussianCoefficients': {\n            value: coefficients\n          } // precomputed Gaussian coefficients\n        },\n\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <common>\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 invSize;\\n\\t\\t\\t\\tuniform vec2 direction;\\n\\t\\t\\t\\tuniform float gaussianCoefficients[KERNEL_RADIUS];\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianCoefficients[0];\\n\\t\\t\\t\\t\\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\\n\\t\\t\\t\\t\\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\n\\t\\t\\t\\t\\t\\tfloat x = float(i);\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianCoefficients[i];\\n\\t\\t\\t\\t\\t\\tvec2 uvOffset = direction * invSize * x;\\n\\t\\t\\t\\t\\t\\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\\n\\t\\t\\t\\t\\t\\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\\n\\t\\t\\t\\t\\t\\tdiffuseSum += (sample1 + sample2) * w;\\n\\t\\t\\t\\t\\t\\tweightSum += 2.0 * w;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getCompositeMaterial\",\n    value: function getCompositeMaterial(nMips) {\n      return new ShaderMaterial({\n        defines: {\n          'NUM_MIPS': nMips\n        },\n        uniforms: {\n          'blurTexture1': {\n            value: null\n          },\n          'blurTexture2': {\n            value: null\n          },\n          'blurTexture3': {\n            value: null\n          },\n          'blurTexture4': {\n            value: null\n          },\n          'blurTexture5': {\n            value: null\n          },\n          'bloomStrength': {\n            value: 1.0\n          },\n          'bloomFactors': {\n            value: null\n          },\n          'bloomTintColors': {\n            value: null\n          },\n          'bloomRadius': {\n            value: 0.0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D blurTexture1;\\n\\t\\t\\t\\tuniform sampler2D blurTexture2;\\n\\t\\t\\t\\tuniform sampler2D blurTexture3;\\n\\t\\t\\t\\tuniform sampler2D blurTexture4;\\n\\t\\t\\t\\tuniform sampler2D blurTexture5;\\n\\t\\t\\t\\tuniform float bloomStrength;\\n\\t\\t\\t\\tuniform float bloomRadius;\\n\\t\\t\\t\\tuniform float bloomFactors[NUM_MIPS];\\n\\t\\t\\t\\tuniform vec3 bloomTintColors[NUM_MIPS];\\n\\n\\t\\t\\t\\tfloat lerpBloomFactor(const in float factor) {\\n\\t\\t\\t\\t\\tfloat mirrorFactor = 1.2 - factor;\\n\\t\\t\\t\\t\\treturn mix(factor, mirrorFactor, bloomRadius);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }]);\n  return UnrealBloomPass;\n}(Pass);\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"names":["AdditiveBlending","Color","HalfFloatType","MeshBasicMaterial","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","LuminosityHighPassShader","UnrealBloomPass","_Pass","_inherits","_super","_createSuper","resolution","strength","radius","threshold","_this","_classCallCheck","call","undefined","x","y","clearColor","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","type","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","bloomFactors","bloomTintColors","copyShader","copyUniforms","blendMaterial","blending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","fsQuad","_createClass","key","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","coefficients","exp","defines"],"sources":["/Users/noamsebahoun/Documents/MMI/MMI_3/karl/three-reader-live/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tHalfFloatType,\n\tMeshBasicMaterial,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n\n\tconstructor( resolution, strength, radius, threshold ) {\n\n\t\tsuper();\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizonal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader\n\t\t} );\n\n\t\t// gaussian blur materials\n\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// composite material\n\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// blend material\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.blendMaterial = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new MeshBasicMaterial();\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t\t//\n\n\t\tfor ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials[ i ].dispose();\n\n\t\t}\n\n\t\tthis.compositeMaterial.dispose();\n\t\tthis.blendMaterial.dispose();\n\t\tthis.basic.dispose();\n\n\t\t//\n\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.blendMaterial;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tgetSeperableBlurMaterial( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );\n\n\t\t}\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}